

<!DOCTYPE html>
<html class="writer-html5" lang="pl" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>31. Złożoność obliczeniowa. Algorytmy dokładne, aproksymacyjne i heurystyczne &mdash; Obrona  - dokumentacja</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=9893e7ba"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="_static/translations.js?v=4c397337"></script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Indeks" href="genindex.html" />
    <link rel="search" title="Szukaj" href="search.html" />
    <link rel="next" title="40. Nowoczesne systemy kryptograficzne stosowane w rozproszonych systemach transakcyjnych." href="40.html" />
    <link rel="prev" title="29 Metody maszynowego uczenia się" href="29.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Obrona
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Szukaj" aria-label="Szukaj" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Spis tresci:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="streszczenie.html">streszczenie</a></li>
<li class="toctree-l1"><a class="reference internal" href="wstep.html">Pojęcia wstępne</a></li>
<li class="toctree-l1"><a class="reference internal" href="1.html">1. Pojęcie algorytmu; typy, własności i przykłady algorytmów.</a></li>
<li class="toctree-l1"><a class="reference internal" href="2.html">2. Diagramy i ich rola w języku SysML; różnice w językach SysML i UML</a></li>
<li class="toctree-l1"><a class="reference internal" href="3.html">3. Modele w przestrzeni stanów. Ocena jakości i porównanie modeli</a></li>
<li class="toctree-l1"><a class="reference internal" href="5.html">5. Statystyczna analiza wyników symulacji</a></li>
<li class="toctree-l1"><a class="reference internal" href="6.html">6. Pojęcie fuzji danych oraz główne obszary jej wykorzystania.</a></li>
<li class="toctree-l1"><a class="reference internal" href="7.html">7. Metody estymacji parametrów systemów dynamicznych. Estymacja zmiennych stanu. Liniowy i rozszerzony filtr Kalmana.</a></li>
<li class="toctree-l1"><a class="reference internal" href="8.html">8. Metody identyfikacji obiektów statycznych w warunkach probabilistycznych. Identyfikacja parametryczna i nieparametryczna.</a></li>
<li class="toctree-l1"><a class="reference internal" href="10.html">10.  Zastosowania programowania liniowego.</a></li>
<li class="toctree-l1"><a class="reference internal" href="11.html">11. Systemy podejmowania i wspomagania decyzji  definicje, metody i algorytmy wyznaczania decyzji, zastosowania.</a></li>
<li class="toctree-l1"><a class="reference internal" href="18.html">18 Typy testów oprogramowania. Definicja i metody badania użyteczności.</a></li>
<li class="toctree-l1"><a class="reference internal" href="19.html">19 Specyfika przetwarzania operacyjnego (OLTP) oraz strategicznego (OLAP), proces eksploracji oraz prezentacji danych w systemach Business Intelligence.</a></li>
<li class="toctree-l1"><a class="reference internal" href="20.html">20 Proces i architektura hurtowni danych, wielowymiarowy model danych.</a></li>
<li class="toctree-l1"><a class="reference internal" href="21.html">21. Zagrożenia i zarządzanie ryzykiem w procesie ochrony infrastruktury krytycznej oraz metody ochrony infrastruktury krytycznej</a></li>
<li class="toctree-l1"><a class="reference internal" href="22.html">22.  Cykl życia przedsiębiorstwa.</a></li>
<li class="toctree-l1"><a class="reference internal" href="23.html">23   Cele i funkcje zarządzania.</a></li>
<li class="toctree-l1"><a class="reference internal" href="29.html">29 Metody maszynowego uczenia się</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">31. Złożoność obliczeniowa. Algorytmy dokładne, aproksymacyjne i heurystyczne</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#zlozonosc-obliczeniowa-algorytmu">Złożoność obliczeniowa algorytmu –</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rozdzaje">Rozdzaje:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#zlozonosc-obliczeniowa">Złożoność obliczeniowa</a></li>
<li class="toctree-l3"><a class="reference internal" href="#glowne-klasy-zlozonosci-obliczeniowej">Główne klasy złożoności obliczeniowej:</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#klasy-zlozonosci-algorytmow">Klasy złożoności algorytmów</a></li>
<li class="toctree-l2"><a class="reference internal" href="#algorytmy-dokladne-aproksymacyjne-i-heurystyczne">Algorytmy dokładne, aproksymacyjne i heurystyczne</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="40.html">40. Nowoczesne systemy kryptograficzne stosowane w rozproszonych systemach transakcyjnych.</a></li>
<li class="toctree-l1"><a class="reference internal" href="42.html">42 Definicje i własności grafów. Modele grafowe.</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Obrona</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">31. Złożoność obliczeniowa. Algorytmy dokładne, aproksymacyjne i heurystyczne</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/31.md.txt" rel="nofollow"> Zobacz źródło strony</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="zlozonosc-obliczeniowa-algorytmy-dokladne-aproksymacyjne-i-heurystyczne">
<h1>31. Złożoność obliczeniowa. Algorytmy dokładne, aproksymacyjne i heurystyczne<a class="headerlink" href="#zlozonosc-obliczeniowa-algorytmy-dokladne-aproksymacyjne-i-heurystyczne" title="Link to this heading"></a></h1>
<p><em><a class="reference external" href="https://medium.com/&#64;danzawadzki/z%C5%82o%C5%BCono%C5%9B%C4%87-obliczeniowa-oraz-notacja-big-o-w-2-minuty-9d022a756008">artykuł big-O</a></em></p>
<section id="zlozonosc-obliczeniowa-algorytmu">
<h2>Złożoność obliczeniowa algorytmu –<a class="headerlink" href="#zlozonosc-obliczeniowa-algorytmu" title="Link to this heading"></a></h2>
<p>ilość zasobów komputerowych potrzebnych do jego wykonania:</p>
<ol class="arabic simple">
<li><p>Złożoność czasowa – to ilość czasu potrzebnego do wykonania zadania, wyrażona jako funkcja ilości danych.</p></li>
<li><p>Złożoność pamięciowa – to ilość pamięci potrzebnej do wykonania zadania, wyrażona jako funkcja ilości danych.</p></li>
</ol>
<section id="rozdzaje">
<h3>Rozdzaje:<a class="headerlink" href="#rozdzaje" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>złożoność pesymistyczna <span class="math notranslate nohighlight">\(O(f(n))\)</span> - określa ilość zasobów (czasu lub pamięci) potrzebnych do wykonania algorytmu przy założeniu wystąpienia „złośliwych” lub najgorszych danych.</p></li>
<li><p>złożoność oczekiwana <span class="math notranslate nohighlight">\(\Theta(f(n))\)</span> - określa ilość zasobów potrzebnych do wykonania algorytmu przy założeniu wystąpienia „typowych” lub oczekiwanych danych</p></li>
<li><p>złożoność optymistyczna <span class="math notranslate nohighlight">\(\Omega(f(n))\)</span>  - ilość zasobów potrzebnych do wykonania algorytmu przy założeniu wystąpienia „najlepszych” danych.</p></li>
</ol>
</section>
<section id="zlozonosc-obliczeniowa">
<h3>Złożoność obliczeniowa<a class="headerlink" href="#zlozonosc-obliczeniowa" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>szacowanie od dołu stwierdzając, iż złożoność obliczeniowa jest nie mniejsza niż pewna klasa funkcji <span class="math notranslate nohighlight">\(\Omega(f(n))\)</span></p></li>
<li><p>szacowanie od góry stwierdzając, iż złożoność obliczeniowa jest nie większa niż pewna klasa funkcji <span class="math notranslate nohighlight">\(O(f(n))\)</span></p></li>
<li><p>szac. Asymptotyczne, szacujące złożoność obliczeniową algorytmu w granicach pewnej klasy funkcji <span class="math notranslate nohighlight">\(\Theta(f(n))\)</span></p></li>
</ol>
</section>
<section id="glowne-klasy-zlozonosci-obliczeniowej">
<h3>Główne klasy złożoności obliczeniowej:<a class="headerlink" href="#glowne-klasy-zlozonosci-obliczeniowej" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(O(1)\)</span> - stała</p></li>
<li><p><span class="math notranslate nohighlight">\(O(n)\)</span> - liniowa</p></li>
<li><p><span class="math notranslate nohighlight">\(O(log(n))\)</span> - logarytmiczna</p></li>
<li><p><span class="math notranslate nohighlight">\(O(nlog(n))\)</span> - liniowo-logarytmiczna</p></li>
<li><p><span class="math notranslate nohighlight">\(O(n^2)\)</span> - kwadratowa</p></li>
<li><p><span class="math notranslate nohighlight">\(O(n^3)\)</span> - sześcienna</p></li>
<li><p><span class="math notranslate nohighlight">\(O(2^n)\)</span> - wykładnicza</p></li>
<li><p><span class="math notranslate nohighlight">\(O(n!)\)</span> - silnia</p></li>
</ol>
<p><img alt="image.png" src="https://static.wikia.nocookie.net/programowanie/images/6/6e/Main-qimg-95eba275e86a62b3d29a80514631bccc.png/revision/latest?cb=20170611092411" /></p>
<div class="admonition note">
<p class="admonition-title">Informacja</p>
<p>Algorytmy o złożoności nie wiekszej niz wielomianowej pozwalają na rozwiązanie zadania w realnym czasie. Natomiast algorytmy o złożoności ponadwielomianowej dla dużych danych są niepraktyczne, gdyż ich wykonanie (dla duzej ilosci danych) mogłoby trwać dłużej niż istnienie Wszechświata.</p>
</div>
</section>
</section>
<section id="klasy-zlozonosci-algorytmow">
<h2>Klasy złożoności algorytmów<a class="headerlink" href="#klasy-zlozonosci-algorytmow" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>łatwe (P - polynomial) - algorytmy wielomianowe, które mogą być rozwiązane w czasie wielomianowym</p></li>
<li><p>trudne (NP - non-deterministic polynomial) - algorytmy dla których nie istnieje (znany) algorytm wielomianowy rozwiązujący problem</p>
<ul class="simple">
<li><p>NP-zupełne (NP-complete) - nie udowodniono braku algorytmu wielomianowego</p></li>
</ul>
</li>
</ol>
<hr class="docutils" />
<p><strong>operacje dominujące</strong> - takie, których łączna liczba jest proporcjonalna do liczby wykonań wszystkich operacji jednostkowych w dowolnej komputerowej realizacji algorytmu</p>
<p><strong>jednostka czasowa</strong> - przyjmuje się wykonanie jednej operacji dominującej.</p>
<p><strong>złożoność pamieciowa</strong> - To ilość dodatkowych jednostek pamięci (najczęściej bajtów lub bitów) potrzebnych do rozwiązania problemu danym algorytmem. Złożoność pamięciową wyrażamy również jako funkcję rozmiaru danych.</p>
<p><strong>Badanie efektywności algorytmu</strong> -Polega na oszacowaniu ich złożoności czasowej i pamięciowej. Poszczególne części algorytmu badane są pod kątem ilości operacji dominujących (porównań, operacji arytmetycznych, przestawień itp.) W zależności od zastosowania oraz rodzaju i rozmiaru przetwarzanych struktur danych można wyróżnić różne operacje dominujące.</p>
</section>
<section id="algorytmy-dokladne-aproksymacyjne-i-heurystyczne">
<h2>Algorytmy dokładne, aproksymacyjne i heurystyczne<a class="headerlink" href="#algorytmy-dokladne-aproksymacyjne-i-heurystyczne" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p><strong>Dokładne</strong> - zwracają rozwiązanie optymalne, najlepsze</p></li>
<li><p><strong>Aproksymacyjne</strong> - zwracają rozwiązanie bliskie optymalnemu, z zadaną dokładnością</p></li>
<li><p><strong>Heurystyczne</strong> - zwracają rozwiązanie bliskie optymalnemu, bez gwarancji dokładności, ale w gwarantowanym czasie</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Informacja</p>
<p>W przypadku dowolnych problemów przeszukiwania metoda heurystyczna może nie zwrócić żadnego rozwiązania, jeśli nie znajdzie dopuszczalnego. Może także (w zależności od potrzeby) naruszyć ograniczenie na dopuszczalność rozwiązania. Powinna wtedy dążyć do wygenerowania rozwiązania jak najbardziej podobnego do rozwiązania dopuszczalnego (np. jak najdłuższa prosta ścieżka w grafie zamiast ścieżki Hamiltona)</p>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="29.html" class="btn btn-neutral float-left" title="29 Metody maszynowego uczenia się" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Poprzedni</a>
        <a href="40.html" class="btn btn-neutral float-right" title="40. Nowoczesne systemy kryptograficzne stosowane w rozproszonych systemach transakcyjnych." accesskey="n" rel="next">Następny <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Prawa zastrzeżone 2023, Michał Skibiński.</p>
  </div>

  Zbudowano w <a href="https://www.sphinx-doc.org/">Sphinx</a> używając
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    dostarczone przez <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>